% タイトル
% 加藤公一
% 2014/7/9

## 自己紹介

----

## 目次

* イントロダクション(数値計算について)
* Numpy/Scipyについて
* 疎行列について
* ケーススタディ

----

## 数値計算(数値解析)

* 常微分方程式、偏微分方程式、各種シミュレーション、機械学習、etc.

----

## 数値計算の道具
* FORTRAN, C
    - 速い
    - 最適化が効く
    - コード書くのが大変
    - デバッグも大変
* Python
    - 生産性高い
    - しかし遅い
    - でもそんなに遅くない

----

## Pythonで数値計算をするメリット

* 生産性が高い
    - デバッグのしやすさ
    - 便利な
* 可視化が(もし必要ならば)楽
    - 各種ウェブフレームワーク
    - グラフの作成(matplotlib)

----

## リスト vs 配列(Numpy)

0から999999の和を計算してみる

```Python
a=range(1000000)
print sum(a)
```

```Python
a=arange(1000000)
print a.sum()
```

```Python
>>> from timeit import timeit
>>> timeit('sum(range(1000000))','from numpy import arange',number=100)
1.927393913269043
>>> timeit('arange(1000000).sum()','from numpy import arange',number=100)
0.10005307197570801
```

----

## 明示的なループは避けるべき

```Python
s=0
for i in range(1000000):
    s+=i
print s
```

これは論外！(常識？)

----

## 2乗和（ノルム）の計算

```Python
def norm(v):
    return (v**2).sum()
```

----

## ブロードキャスティング

```Python
import numpy as np
a=np.array([1,2,3])
print a*2 # => array([2,4,6])
print np.sin(a*np.pi/2) # => array([1,0,1]) (だだし多少の誤差あり)
```

----

## 要素ごとの計算

```Python
>>> a=np.array([[1,2,3],[4,5,6],[7,8,9]])
>>> b=np.array([[1,0,0],[0,1,0],[0,0,1]])
>>> a*b
array([[1, 0, 0],
       [0, 5, 0],
       [0, 0, 9]])
>>> np.dot(a,b)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

----

## 疎行列とは

ほとんどの値がゼロである行列。

----

## numpy.sparse

主に3つの疎行列型 :`lil_matrix`, `csr_matrx`, `csc_matrix`
(他にもあるが今日は忘れよう)

`lil_matrix`: 値を詰めるのに便利、実際の計算は`csr_matrix`や`csc_matrix`に変換してから行う

```Python
import scipy.sparse as sparse
a=sparse.lil_matrix((100,100))
a[0,0]=1.0
a[2,0]=2.0
a[0,5]=5.0
x=a.tocsr()
# xに関する計算
```

* `csr_matrix`: 行を取り出すのは高速。csr_matrix同士の和や積は高速。
* `csc_matrix`: 行を取り出すのは高速。csc_matrix同士の和や積は高速。


----

## シグモイド関数の作用

$$ \sigma(x) = \frac{1}{1+e^{-x}} $$

```Python
def sig_warn(a):
    return 1/(1+np.exp(-a))

def sig(a):
    return np.where(a<-1e700,0.0,1/(1+np.exp(a)))
```

(Warningを無視していいのなら、1/infはちゃんと0になってくれるのでそんなに問題はない？)

```Python
>>> x=np.array([-1e100,1,-10])
>>> sig_bad(x)
sig.py:4: RuntimeWarning: overflow encountered in exp
  return 1/(1+np.exp(-a))
array([  0.00000000e+00,   7.31058579e-01,   4.53978687e-05])
>>> sig(x)
array([ 1.        ,  0.26894142,  0.9999546 ])
```

----

## ノルムの計算

```Python
print a.multiply(a).sum()
r=a.getrow(i)
print r.multiply(r).sum()
```

----

## ユニバーサル関数の作用
配列の各要素に作用できるユニバーサル関数は便利。

でも、これは疎行列にはそのまま使えない。$x=0$のときに$f(x)=0$となる関数なら、関数を作用させたあとも疎行列のはずである。

```Python
import numpy as np
improt scipy.sparse as sparse
a=np.array([1,2,3])
b=sparse.lil_matrix((100,100))
b[0,0]=1.0
b[1,1]=2.0
b[2,2]=3.0
print np.tanh(a) # 計算できる
print np.tanh(b) # エラーになる
```

----

## ではどうするか？

* scipy.sparseの内部型を直接いじる
* ここでもブロードキャスティングを利用

----

## 内部型とコンストラクタ

```Python

```

----


## 参考文献

* Stéfan van der Walt, [Numpy Medkit](http://mentat.za.net/numpy/numpy_advanced_slides/)
* Gabriele Lanaro, "Python High Performance Programming," Packt Publishing, 2013.
